/*
 *  Portions Copyright (C) 2003 Ben Goodwin
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the OSML - Open Source Modification License v1.0 as
 *  described in the file COPYING which is distributed with this source
 *  code.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */

#include "g_local.h"
#include "q3as.h"

// globals
as_modeInfo_t	as_mode;
as_allModes_t	as_modes;

/*******************************************************************************************************
 *												FUNCTIONS
 *******************************************************************************************************/

// This reads in a binary data file containing all mode config information
// This data file is generated by the 'modegen' project found in the 'modegen'
// folder (off the root q3as folder)
static void as_loadModeData(char *filename) {
	fileHandle_t		f;
	int					num;
	as_modeHeader_t		header;

	as_debug("Loading header from %s\n", filename);
	num = trap_FS_FOpenFile(filename, &f, FS_READ);
	if (!f) {
		G_Error("Unable to read current map information from %s!\n", filename);
		return;
	} else {
		trap_FS_Read(&header, sizeof(header), f);
		trap_FS_FCloseFile(f);
	}

	if (header.interfaceVersion != AS_MODE_INTERFACE_VERSION)
		G_Error("Modefile (%s) interface version %d found (expecting %d)\n", filename,
			header.interfaceVersion, AS_MODE_INTERFACE_VERSION);

	as_debug("Loading all of %s\n", filename);
	G_Printf("Loading modes from %s (revision %d)\n", filename, header.fileVersion);
	num = trap_FS_FOpenFile(filename, &f, FS_READ);
	if (!f) {
		G_Error("Unable to read current map information from %s!\n", filename);
	} else if (num != sizeof(as_modes)) { 
		G_Error("Size of data read from %s does not match the struct size (%d)!\n", filename, sizeof(as_modes));
	} else {
		trap_FS_Read(&as_modes, sizeof(as_modes), f);
		trap_FS_FCloseFile(f);
	}
}

void as_initMode(int mode) {
	int				i;

	as_loadModeData(as_mode_file.string);

	if (mode < 0 || mode >= as_modes.header.numModes)
		G_Error("Invalid mode specified: %d\n", mode);

	G_Printf("Setting mode to: %d\n", mode);

	memcpy(&as_mode, &(as_modes.mi[mode]), sizeof(as_mode));

	if (as_mode.mask & AS_MM_NOFALLING)
		g_dmflags.integer |= DF_NO_FALLING;

	if (as_mode.mask & AS_MM_SHORTMINE)
		trap_Cvar_Set("g_proxMineTimeout", va("%d", 10000));

	if (as_mode.mask & AS_MM_LONGMINE)
		trap_Cvar_Set("g_proxMineTimeout", va("%d", 25000));

	as_setWRCS();

	for (i = 1; i < WP_NUM_WEAPONS; i++) {
		if (as_mode.ammo[g_gametype.integer].startWith[i] > 0) {
			RegisterItem( BG_FindItemForWeapon(i) );
		}
	}
	for (i = 1; i < HI_NUM_HOLDABLE; i++) {
		if (as_mode.holdable.startWith[i] > 0) {
			RegisterItem( BG_FindItemForHoldable(i) );
		}
	}
	for (i = 1; i < PW_NUM_POWERUPS; i++) {
		if (as_mode.powerup.startWith[i] > 0) {
			RegisterItem( BG_FindItemForPowerup(i) );
		}
	}

	if (as_preserve_gamename.integer == 0)
		trap_Cvar_Set("gamename", as_mode.gamename);
	G_Printf("Mode '%s' initialized.\n", as_mode.fullname);
}

qboolean as_itemDisabled (gitem_t *item) {
	int		mask;

	if (!item)
		return qfalse;

	switch (item->giType) {
	case IT_WEAPON:
		mask = as_mode.weapon.spawnMask;
		break;
	case IT_AMMO:
		mask = as_mode.ammo[g_gametype.integer].spawnMask;
		break;
	case IT_POWERUP:
	case IT_PERSISTANT_POWERUP:
		mask = as_mode.powerup.spawnMask;
		break;
	case IT_ARMOR:
		mask = as_mode.armor.spawnMask;
		break;
	case IT_HEALTH:
		mask = as_mode.health.spawnMask;
		break;
	case IT_HOLDABLE:
		mask = as_mode.holdable.spawnMask;
		break;
	default:
		return qfalse;
	}

	if ( (1 << item->giTag) & mask )
		return qfalse;
	else
		return qtrue;
}

gitem_t	*as_swapItem(gitem_t *item) {
	gitem_t		*newItem;

	if (!item)
		return item;

	if (as_mode.swap[item - bg_itemlist] == 0)
		return item;

	newItem = &bg_itemlist[as_mode.swap[item - bg_itemlist]];

	if (item != newItem) {
		as_debug("Swapping %s for %s\n", item->classname, newItem->classname);
		RegisterItem(newItem);
		return newItem;
	} else {
		return item;
	}
}

void as_modifyItem(gentity_t *ent, gitem_t *item) {
	if (!(ent && item))
		return;

	if (as_mode.value[item - bg_itemlist] == item->quantity)
		return;

	// -1 meaning 'use default'
	if (as_mode.value[item - bg_itemlist] == -1)
		return;

	item->quantity = as_mode.value[item - bg_itemlist];
	ent->count = item->quantity;
}

void as_giveStartWeapons(gclient_t *client) {
	int				i;

	if (!client)
		return;

	client->ps.stats[STAT_WEAPONS] = 0;
	for (i = 1; i < WP_NUM_WEAPONS; i++) {
		if (as_mode.weapon.startWith[i])
			client->ps.stats[STAT_WEAPONS] |= ( 1 << i );
		client->ps.ammo[i] = as_mode.ammo[g_gametype.integer].startWith[i];
	}
}

#ifdef MISSIONPACK
int Pickup_PersistantPowerup( gentity_t *ent, gentity_t *other );
void as_giveStartPersistentPowerup(int giTag, gentity_t *other) {
	gentity_t	*ent;

	if (!other)
		return;

	ent = G_Spawn();
	ent->item = BG_FindItemForPowerup(giTag);
	if (ent->item) {
		ent->classname = ent->item->classname;
		Pickup_PersistantPowerup(ent, other);
		ent->flags |= FL_GIVEN_PERSISTENT;	// FREE this entity instead of trying to return it to base
	}
}
#endif

void as_giveStartOther(gentity_t *ent) {
	gclient_t		*client;
	gitem_t			*item;
	int				i;

	if (!(ent && ent->client))
		return;

	client = ent->client;

	// powerups
	for (i = 1; i <= PW_FLIGHT; i++ ) {
		if (as_mode.powerup.startWith[i]) {
			client->ps.powerups[i] = level.time + as_mode.powerup.startWith[i] * 1000;
		}
	}
#ifdef MISSIONPACK
	for (i = PW_SCOUT; i <= PW_AMMOREGEN; i++) {
		if (as_mode.powerup.startWith[i]) {
			if (client->ps.stats[STAT_PERSISTANT_POWERUP] == 0) {
				as_giveStartPersistentPowerup(i, ent);
			}
		}
	}
#endif

	// armor
	ent->health = client->ps.stats[STAT_ARMOR] += as_mode.armor.spawnBonus;

	// holdable
	for (i = 1; i < HI_NUM_HOLDABLE; i++) {
		if (as_mode.holdable.startWith[i]) {
			if (client->ps.stats[STAT_HOLDABLE_ITEM] == 0) {
				item = BG_FindItemForHoldable(i);
				client->ps.stats[STAT_HOLDABLE_ITEM] = item - bg_itemlist;
				if (i == HI_KAMIKAZE)
					ent->client->ps.eFlags |= EF_KAMIKAZE;
			}
		}
	}
}

// set WeaponRate ConfigString
// This is needed so client can get weapon rate
void as_setWRCS( void ) {
	char		info[MAX_INFO_STRING];
	int			i;
	gitem_t		*item;

	as_debug ("Creating string for CS_AS_WR ...\n");
	memset(info, 0, sizeof(info));

	for (i = 1; i < WP_NUM_WEAPONS; i++) {
		item = BG_FindItemForWeapon(i);
		Com_sprintf(info, sizeof(info), "%s\\x%dx\\%d", info, item->giTag, as_mode.weapon.firingRate[i]);
	}

	as_debug ("Setting CS_AS_WR to %s\n", info);
	trap_SetConfigstring( CS_AS_WR, info);
}

int as_getWeaponRate(int weapon) {
	return (as_mode.weapon.firingRate[weapon]);
}

// This is AFTER Q3's regen/guard, so no need
// to check for those conditions
qboolean as_shouldDecayHealth(gentity_t *ent) {
	if (as_mode.mask & AS_MM_NOHEALTHDECAY)
		return qfalse;
	if (as_mode.mask & AS_MM_REGENHEALTH)
		return qfalse;
	return qtrue;
}

qboolean as_shouldDecayArmor(gentity_t *ent) {
	if (as_mode.mask & AS_MM_NOARMORDECAY)
		return qfalse;
	if (as_mode.mask & AS_MM_REGENARMOR)
		return qfalse;
	return qtrue;
}

void as_regenVitals(gentity_t *ent) {
	if (!(ent && ent->client))
		return;

	if (as_mode.mask & AS_MM_REGENHEALTH) {
		if (level.time - ent->client->q3as.lastHealthRegenTime >= as_mode.health.regenRate) {
			ent->client->q3as.lastHealthRegenTime = level.time;
			ent->health += as_mode.health.regenInc;
			if (ent->health > as_mode.health.regenMax)
				ent->health = as_mode.health.regenMax;
		}
	}

	if (as_mode.mask & AS_MM_REGENARMOR) {
		if (level.time - ent->client->q3as.lastArmorRegenTime >= as_mode.armor.regenRate) {
			ent->client->q3as.lastArmorRegenTime = level.time;
			ent->client->ps.stats[STAT_ARMOR] += as_mode.armor.regenInc;
			if (ent->client->ps.stats[STAT_ARMOR] > as_mode.armor.regenMax)
				ent->client->ps.stats[STAT_ARMOR] = as_mode.armor.regenMax;
		}
	}
}

void as_regenAmmo(gentity_t *ent) {
	int				i;

	if (!(ent && ent->client))
		return;

	if (as_mode.mask & AS_MM_REGENAMMO) {
		for (i = 1; i < WP_NUM_WEAPONS; i++) {
			if (level.time - ent->client->q3as.lastAmmoRegenTime[i] >= as_mode.ammo[g_gametype.integer].regenRate[i]) {
				if (ent->client->ps.stats[STAT_WEAPONS] & ( 1 << i ) ) {
					if (as_mode.ammo[g_gametype.integer].regenInc[i]) {
						ent->client->q3as.lastAmmoRegenTime[i] = level.time;
						ent->client->ps.ammo[i] += as_mode.ammo[g_gametype.integer].regenInc[i];
						if (ent->client->ps.ammo[i] > as_mode.ammo[g_gametype.integer].regenMax[i])
							ent->client->ps.ammo[i] = as_mode.ammo[g_gametype.integer].regenMax[i];
					}
				}
			}
		}
	}
}

void as_modifyRespawn(gentity_t *ent, int *respawn) {
	if (!(ent && ent->item))
		return;

	if (as_mode.respawn[ent->item - bg_itemlist] != -2) {
		*respawn = as_mode.respawn[ent->item - bg_itemlist];
		ent->random = ent->wait = 0;
	}
}

void as_getVoteableModeList(char *buffer, int size) {
	int			i;

	memset(buffer, 0, size);

	for (i = 0; i < as_modes.header.numModes; i++) {
		if ( as_vote_mode_mask.integer & ( 1 << i ) )
			if (strlen(buffer))
				Com_sprintf(buffer, size, "%s, %d (%s)", buffer, i, as_modes.mi[i].fullname);
			else
				Com_sprintf(buffer, size, "%d (%s)", i, as_modes.mi[i].fullname);
	}

	if (!strlen(buffer))
		Com_sprintf(buffer, size, "NONE!");
}

